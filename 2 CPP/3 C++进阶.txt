## 1 成员变量和函数的存储

> 空类的sizeof结果 = 1

- C++类对象中的变量和函数是分开存储
  - 静态数据成员并不保存在类对象中
  - 静态成员函数也不保存在类对象中
  - 非静态成员函数不保存在类对象中

## 2 this指针

> this指针指向被调用的成员函数所属的对象(指向本对象的指针)

- this指针是隐含在对象成员函数内的一种指针，\*this就是本体
  - 静态成员函数内部没有this指针，静态成员函数不能操作非静态成员变量
- 当一个对象被创建后，它的每一个成员函数都含有一个系统自动生成的隐含指针this，用以保存这个对象的地址
- this指针并不是对象的一部分，不会影响sizeof(对象)的结果

### 2.1 this指针的使用

- 当形参和成员变量同名时，可用this指针来区分
- 在类的非静态成员函数中返回对象本身，可使用return *this

## 3 const

### 3.1 const修饰成员函数

- 用const修饰的成员函数时，const修饰this指针指向的内存区域
- 对于成员函数 ，不可以用static和const同时修饰

> 示例：`void Operate() const{};`
>
> - 成员函数体内不可以修改本类中的任何普通成员变量	
> - 当成员变量类型符前用mutable修饰时例外

### 3.2 const修饰对象(常对象)

- 常对象只能调用const的成员函数(常函数)
- 常对象可访问const或非const数据成员，不能修改，除非成员用mutable修饰

> 空指针访问成员函数
>
> - 如果成员函数中没有用到this指针，可以用空指针调用成员函数
> - 如果成员函数中用到了this，那么这个this需要加判断，防止代码出错

## 4 友元

> 通过友元关系，在类的外部访问类的私有成员
>
> - 友元关系不能被继承，不具有传递性，是单向的

- 其他类、类成员函数、全局函数都可声明为友元
- 友元函数可访问对象任意成员属性，包括私有属性

## 5 运算符重载

- 重载左移操作符(<<)
  - `friend ostream& operator<<(ostream& os, Person& person);`
- 重载递增运算符
- 重载指针运算符
  - 智能指针，用于托管new出来的对象的释放
- =, [], () 和 -> 操作符只能通过成员函数进行重载
- 不能重载的运算符
  - `.	::	 .*	?:	sizeof()`
  - 不能重载operator&& 和 operator||
    - 无法在这两种情况下实现内置操作符的完整语义(无法实现短路特性)

## 6 C++类型转换

### 6.1 静态转换static_cast

> 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换
>
> 用于基本数据类型之间的转换
>
> 无继承关系指针转换，转换失败

- 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的
- 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，是不安全的

### 6.2 动态转换dynamic_cast

> 主要用于类层次间的上行转换和下行转换
>
> 不支持基础数据类型之间的转换
>
> 无继承关系指针转换，转换失败

- 在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的
- 在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全

### 6.3 常量转换const_cast

> 常量指针被转化成非常量指针/引用，并且仍然指向原来的对象

- 不能直接对非指针和非引用的变量使用const_cast操作符去直接移除它的const

### 6.4 重新解释转换reinterpret_cast

> 这是最不安全的一种转换机制，最有可能出问题
>
> 主要用于将一种数据类型从一种类型转换为另一种类型

- 可以将一个指针转换成一个整数，也可以将一个整数转换成一个指针



