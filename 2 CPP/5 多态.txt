## 1 多态

- c++支持编译时多态(静态多态)和运行时多态(动态多态)
  - 静态多态：运算符重载和函数重载就是编译时多态
  - 动态多态：派生类和虚函数实现运行时多态
  - 静态多态和动态多态的区别就是函数地址是早绑定(静态联编)还是晚绑定(动态联编)
    - 如果函数的调用，在编译阶段就可以确定函数的调用地址，并产生代码，就是静态多态
    - 如果函数的调用地址不能在编译期间确定，而需要在运行时才能决定，这就属于晚绑定
- 多态实现的条件
  - 先有继承关系
  - 父类中有虚函数，子类重写父类中的虚函数
  - 父类的指针或引用，指向子类的对象	

> C++动态多态性是通过虚函数来实现的
>
> - 虚函数允许子类（派生类）重新定义父类（基类）成员函数
> - 子类（派生类）重新定义父类（基类）虚函数的做法称为覆盖(override)，或者称为重写

## 2 向上类型转换

- 对象可以作为自己的类或者作为它的基类的对象来使用，还能通过基类的地址来操作它
- 父类引用或指针可以指向子类对象，通过父类指针或引用来操作子类对象

## 3 虚函数

> 为创建一个需要动态绑定的虚成员函数，可以简单在这个函数声明前面加上virtual关键字，定义时候不需要

- 如果一个函数在基类中被声明为virtual，那么在所有派生类中它都是virtual的
- 在派生类中virtual函数的重定义称为重写(override)
- 构造函数不能为虚函数

### 3.1 虚析构函数

> 为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象
>
> 如果子类中有指向堆区的属性，那么要利用虚析构技术在delete的时候，调用子类的析构函数

- 纯虚析构函数
  - 纯虚析构函数在c++中是合法的，但是在使用的时候必须为纯虚析构函数提供一个函数体
  - 纯虚析构函数使得基类是抽象类，不能创建基类的对象

## 4 抽象类

> 在基类中加入至少一个纯虚函数(pure virtual function),使得基类称为抽象类
>
> - 纯虚函数使用关键字virtual，并在其后面加上=0

- 如果试图去实例化一个抽象类，编译器则会阻止这种操作
- 当继承一个抽象类的时候，必须实现所有的纯虚函数，否则由抽象类派生的类也是一个抽象类



