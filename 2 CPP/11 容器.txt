1）string容器
	C风格字符串(以空字符结尾的字符数组)太过复杂难于掌握
	C++标准库定义了一种string类，定义在头文件<string>
		Char*是一个指针，String是一个类（string封装了char*）
		String封装了很多实用的成员方法，查找find，拷贝copy，删除delete 替换replace，插入insert
		不用考虑内存释放和越界

	 string 构造函数
		string();	//创建一个空的字符串 例如: string str;      
		string(const string& str);	//使用一个string对象初始化另一个string对象
		string(const char* s);		//使用字符串s初始化
		string(int n, char c);		//使用n个字符c初始化
	string基本赋值操作
		string& operator=(const char* s);	//char*类型字符串 赋值给当前的字符串
		string& assign(const char *s);		//把字符串s赋给当前的字符串
		string& operator=(const string &s);	//把字符串s赋给当前字符串
		string& assign(const string &s);		//把字符串s赋给当前字符串
		string& operator=(char c);		//字符赋值给当前的字符串
		string& assign(int n, char c);		//用n个字符c赋给当前字符串
		string& assign(const char *s, int n);	//把字符串s的前n个字符赋给当前的字符串
		string& assign(const string &s, int start, int n);	//将s从start开始n个字符赋值给字符串
	string存取字符操作
		char& operator[](int n);	//通过[]方式取字符
		char& at(int n);		//通过at方法获取字符
	string拼接操作
		string& operator+=(const string& str);	//重载+=操作符
		string& operator+=(const char* str);	//重载+=操作符
		string& operator+=(const char c);	//重载+=操作符
		string& append(const char *s);		//把字符串s连接到当前字符串结尾
		string& append(const char *s, int n);	//把字符串s的前n个字符连接到当前字符串结尾
		string& append(const string &s);	//同operator+=()
		string& append(const string &s, int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾
		string& append(int n, char c);		//在当前字符串结尾添加n个字符c
	string查找和替换
		int find(const string& str, int pos = 0) const; 	//查找str第一次出现位置,从pos开始查找
		int find(const char* s, int pos = 0) const;  		//查找s第一次出现位置,从pos开始查找
		int find(const char* s, int pos, int n) const;  	//从pos位置查找s的前n个字符第一次位置
		int find(const char c, int pos = 0) const;  		//查找字符c第一次出现位置
		int rfind(const string& str, int pos = npos) const;	//查找str最后一次位置,从pos开始查找
		int rfind(const char* s, int pos = npos) const;	//查找s最后一次出现位置,从pos开始查找
		int rfind(const char* s, int pos, int n) const;	//从pos查找s的前n个字符最后一次位置
		int rfind(const char c, int pos = 0) const; 		//查找字符c最后一次出现位置
		string& replace(int pos, int n, const string& str); 	//替换从pos开始n个字符为字符串str
		string& replace(int pos, int n, const char* s);	//替换从pos开始的n个字符为字符串s
	string比较操作
		int compare(const string &s) const;	//与字符串s比较
		int compare(const char *s) const;	//与字符串s比较
			compare函数在>时返回 1，<时返回 -1，==时返回 0
			比较区分大小写，比较时参考字典顺序，排越前面的越小
			大写的A比小写的a小
	string子串
		string substr(int pos = 0, int n = npos) const;//返回由pos开始的n个字符组成的字符串
	string插入和删除操作
		string& insert(int pos, const char* s); 	//插入字符串
		string& insert(int pos, const string& str); 	//插入字符串
		string& insert(int pos, int n, char c);	//在指定位置插入n个字符c
		string& erase(int pos, int n = npos);	//删除从Pos开始的n个字符 
	string和c-style字符串转换
		string 转 char*
			string str = "itcast";
			const char* cstr = str.c_str();
		char* 转 string 
			char* s = "itcast";
			string str(s);
=========================================================================
2）vector容器
	头文件#include<vector>

	动态增加大小，并不是在原空间之后续接新空间(因为无法保证原空间之后尚有可配置的空间)，而是一块更大的内存空间，然后将原数据拷贝新空间，并释放原空间
	因此，对vector的任何操作，一旦引起空间的重新配置，指向原vector的所有迭代器就都失效了

	用swap，收缩内存空间
		vector<int> v;
		v.resize(10);		//通过resize改变容器大小
		vector<int>(v).swap(v);	//采用匿名对象,达到收缩内存空间的目的

	vector构造函数
		vector<T> v; 		//采用模板实现类实现，默认构造函数
		vector(v.begin(), v.end());	//将v[begin(), end())区间中的元素拷贝给本身
			--int arr[] = {2,3,4,1,9};
			--vector<int> v1(arr, arr + sizeof(arr) / sizeof(int));
		vector(n, elem);		//构造函数将n个elem拷贝给本身
		vector(const vector &vec);	//拷贝构造函数
	vector常用赋值操作
		assign(beg, end);		//将[beg, end)区间中的数据拷贝赋值给本身
		assign(n, elem);		//将n个elem拷贝赋值给本身
		vector& operator=(const vector  &vec);//重载等号操作符
		swap(vec);			// 将vec与本身的元素互换
	vector大小操作
		size();		//返回容器中元素的个数
		empty();		//判断容器是否为空
		resize(int num);	//重新指定容器的长度为num
			若容器变长，则以默认值填充新位置
			如果容器变短，则末尾超出容器长度的元素被删除
		resize(int num, elem);//重新指定容器的长度为num
			若容器变长，则以elem值填充新位置
			如果容器变短，则末尾超出容器长>度的元素被删除
		capacity();		//容器的容量
		reserve(int len);	//容器预留len个元素长度，预留位置不初始化，元素不可访问
	vector数据存取操作
		at(int idx); 	//返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。
		operator[];	//返回索引idx所指的数据，越界时，运行直接报错
		front();		//返回容器中第一个数据元素
		back();		//返回容器中最后一个数据元素
	vector插入和删除操作
		insert(const_iterator pos, int count,ele);	//迭代器指向位置pos插入count个元素ele.
		push_back(ele); 			//尾部插入元素ele
		pop_back();			//删除最后一个元素
		erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素
		erase(const_iterator pos);		//删除迭代器指向的元素
		clear();				//删除容器中所有元素
=========================================================================
3）deque容器
	deque是一种双向开口的连续线性空间
	除非有必要，我们应该尽可能的使用vector，而不是deque
	对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector中，对vector容器进行排序，再复制回deque
	Deque采取一块所谓的map(不是STL的map容器)作为主控，这里所谓的map是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是deque的存储空间的主体

	deque构造函数
		deque<T> deqT;		//默认构造形式
		deque(beg, end);		//构造函数将[beg, end)区间中的元素拷贝给本身
		deque(n, elem);		//构造函数将n个elem拷贝给本身
		deque(const deque &deq);	//拷贝构造函数
	deque赋值操作
		assign(beg, end);		//将[beg, end)区间中的数据拷贝赋值给本身。
		assign(n, elem);		//将n个elem拷贝赋值给本身。
		deque& operator=(const deque &deq); //重载等号操作符 
		swap(deq);		// 将deq与本身的元素互换
	deque大小操作
		deque.size();//返回容器中元素的个数
		deque.empty();//判断容器是否为空
		deque.resize(num);//重新指定容器的长度为num
		deque.resize(num, elem); //重新指定容器的长度为num,以elem值填充新位置
	deque双端插入和删除操作
		push_back(elem);	//在容器尾部添加一个数据
		push_front(elem);	//在容器头部插入一个数据
		pop_back();	//删除容器最后一个数据
		pop_front();	//删除容器第一个数据
	deque数据存取
		at(idx);		//返回索引idx所指的数据，如果idx越界，抛出out_of_range。
		operator[];	//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。
		front();		//返回第一个数据。
		back();		//返回最后一个数据
	deque插入操作
		insert(pos,elem);		//在pos位置插入一个elem元素的拷贝，返回新数据的位置。
		insert(pos,n,elem);		//在pos位置插入n个elem数据，无返回值。
		insert(pos,beg,end);		//在pos位置插入[beg,end)区间的数据，无返回值。
	deque删除操作
		clear();		//移除容器的所有数据
		erase(beg,end);	//删除[beg,end)区间的数据，返回下一个数据的位置。
		erase(pos);	//删除pos位置的数据，返回下一个数据的位置。
=========================================================================
4）stack容器
	stack是一种先进后出(First In Last Out,FILO)的数据结构
	stack没有迭代器

	stack构造函数
		stack<T> stkT;	//stack采用模板类实现， stack对象的默认构造形式
		stack(const stack &stk);	//拷贝构造函数
	stack赋值操作
		stack& operator=(const stack &stk);	//重载等号操作符
	stack数据存取操作
		push(elem);	//向栈顶添加元素
		pop();		//从栈顶移除第一个元素
		top();		//返回栈顶元素
	stack大小操作
		empty();		//判断堆栈是否为空
		size();		//返回堆栈的大小
=========================================================================
5）queue容器
	Queue是一种先进先出(First In First Out,FIFO)的数据结构，允许从一端新增元素，从另一端移除元素
	queue构造函数
		queue<T> queT;	//queue采用模板类实现，queue对象的默认构造形式：
		queue(const queue &que);	//拷贝构造函数
	queue存取、插入和删除操作
		push(elem);	//往队尾添加元素
		pop();		//从队头移除第一个元素
		back();		//返回最后一个元素
		front();		//返回第一个元素
	queue赋值操作
		queue& operator=(const queue &que);	//重载等号操作符
	queue大小操作
		empty();		//判断队列是否为空
		size();		//返回队列的大小
=========================================================================
6）list容器
	list构造函数
		list<T> lstT;	//list采用采用模板类实现,对象的默认构造形式：
		list(beg,end);	//构造函数将[beg, end)区间中的元素拷贝给本身。
		list(n,elem);	//构造函数将n个elem拷贝给本身。
		list(const list &lst);	//拷贝构造函数。
	list数据元素插入和删除操作
		push_back(elem);	//在容器尾部加入一个元素
		pop_back();	//删除容器中最后一个元素
		push_front(elem);	//在容器开头插入一个元素
		pop_front();	//从容器开头移除第一个元素
		insert(pos,elem);	//在pos位置插elem元素的拷贝，返回新数据的位置。
		insert(pos,n,elem);	//在pos位置插入n个elem数据，无返回值。
		insert(pos,beg,end);	//在pos位置插入[beg,end)区间的数据，无返回值。
		clear();		//移除容器的所有数据
		erase(beg,end);	//删除[beg,end)区间的数据，返回下一个数据的位置。
		erase(pos);	//删除pos位置的数据，返回下一个数据的位置。
		remove(elem);	//删除容器中所有与elem值匹配的元素。
	list大小操作
		size();		//返回容器中元素的个数
		empty();		//判断容器是否为空
		resize(num);	//重新指定容器的长度为num，
			若容器变长，则以默认值填充新位置。
			如果容器变短，则末尾超出容器长度的元素被删除。
		resize(num, elem);//重新指定容器的长度为num，
			若容器变长，则以elem值填充新位置。
			如果容器变短，则末尾超出容器长度的元素被删除。
	list赋值操作
		assign(beg, end);	//将[beg, end)区间中的数据拷贝赋值给本身。
		assign(n, elem);	//将n个elem拷贝赋值给本身。
		list& operator=(const list &lst);		//重载等号操作符
		swap(lst);		//将lst与本身的元素互换。
	list数据的存取
		front();		//返回第一个元素。
		back();		//返回最后一个元素。
	list反转排序
		reverse();		//反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。
		sort(); 		//list排序
=========================================================================
7）set/multiset容器
	set构造函数
		set<T> st;		//set默认构造函数：
		mulitset<T> mst; 	//multiset默认构造函数: 
		set(const set &st);	//拷贝构造函数
	set赋值操作
		set& operator=(const set &st);		//重载等号操作符
		swap(st);		//交换两个集合容器
	set大小操作
		size();		//返回容器中元素的数目
		empty();		//判断容器是否为空
	set插入和删除操作
		insert(elem);	//在容器中插入元素。
		clear();		//清除所有元素
		erase(pos);	//删除pos迭代器所指的元素，返回下一个元素的迭代器。
		erase(beg, end);	//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
		erase(elem);	//删除容器中值为elem的元素。
	set查找操作
		find(key);		//查找键key是否存在,若存在，返回该键的元素的迭代器；
			若不存在，返回set.end();
		count(key);	//查找键key的元素个数
		lower_bound(keyElem);	//返回第一个key>=keyElem元素的迭代器。
		upper_bound(keyElem);	//返回第一个key>keyElem元素的迭代器。
		equal_range(keyElem);	//返回容器中key与keyElem相等的上下限的两个迭代器。
=========================================================================
8）map/multimap容器
	 map构造函数
		map<T1, T2> mapTT;	//map默认构造函数: 
		map(const map &mp);	//拷贝构造函数
	map赋值操作
		map& operator=(const map &mp);	//重载等号操作符
		swap(mp);			//交换两个集合容器
	map大小操作
		size();		//返回容器中元素的数目
		empty();		//判断容器是否为空
	map插入数据元素操作
		map.insert(...); //往容器插入元素，返回pair<iterator,bool>
		map<int, string> mapStu;
		// 第一种 通过pair的方式插入对象
			mapStu.insert(pair<int, string>(3, "小张"));
		// 第二种 通过pair的方式插入对象
			mapStu.inset(make_pair(-1, "校长"));
		// 第三种 通过value_type的方式插入对象
			mapStu.insert(map<int, string>::value_type(1, "小李"));
		// 第四种 通过数组的方式插入值
			mapStu[3] = "小刘";
	map删除操作
		clear();		//删除所有元素
		erase(pos);	//删除pos迭代器所指的元素，返回下一个元素的迭代器。
		erase(beg,end);	//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
		erase(keyElem);	//删除容器中key为keyElem的对组。
	map查找操作
		find(key);		//查找键key是否存在,若存在，返回该键的元素的迭代器；
			若不存在，返回map.end();
		count(keyElem);	//返回容器中key为keyElem的对组个数
			对map来说，要么是0，要么是1。对multimap来说，值可能大于1。
		lower_bound(keyElem);	//返回第一个key>=keyElem元素的迭代器。
		upper_bound(keyElem);	//返回第一个key>keyElem元素的迭代器。
		equal_range(keyElem);	//返回容器中key与keyElem相等的上下限的两个迭代器。
=========================================================================