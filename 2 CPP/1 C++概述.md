## 1 概述

- c++语言在c语言的基础上添加了面向对象编程和泛型编程的支持
- 面向过程编程思想的核心：功能分解，自顶向下，逐层细化
- 面向对象三大特性：封装、继承、多态
  - 在面向对象中，算法与数据结构被看做是一个整体，称作对象

## 2 C++对C的扩展

### 2.1 作用域运算符 '::'

> 作用域运算符用来解决局部变量与全局变量的重名问题
>
> - 通常情况下，如果有两个同名变量，一个是全局变量，另一个是局部变量，那么局部变量在其作用域内具有较高的优先权，它将屏蔽全局变量

### 2.2 命名空间

> 避免标识符的命名发生冲突，通过namespace更好地控制标识符的作用域
>
> - 无名命名空间，意味着命名空间中的标识符只能在本文件内访问，相当于给这个标识符加上了static，使得其可以作为内部连接

- 命名空间只能全局范围内定义
- 命名空间可嵌套命名空间
- 命名空间内的声明和实现可分离
- 命名空间是开放的，即可以随时把新的成员加入已有的命名空间中

### 2.3 using声明

> using声明可使得指定的标识符可用

### 2.4 全局变量检测增强

```
int a; 			//没有赋值，当做声明
int a = 10; 	//赋值，当做定义
```

### 2.5 类型转换检测增强

```
char * p = (char *)malloc(64)	//C++下必须等号左右一致类型
```

### 2.6 struct类型加强

- c中定义结构体变量需要加上struct关键字；c++不需要
- c中的结构体只能定义成员变量，不能定义成员函数；c++既可以定义成员变量，也定义成员函数

### 2.7 新增bool类型关键字

> 标准c++的bool类型有两种内建的常量true(转换为整数1)和false(转换为整数0)表示状态

### 2.8 三目运算符功能增强

- C语言三目运算表达式返回值为数据值(右值)，不能赋值
- c++语言三目运算表达式返回值为变量本身(引用)，为左值，可以赋值

> 左值为Lvalue，L代表Location，表示内存可以寻址，可以赋值
>
> 右值为Rvalue，R代表Read，表示可以知道它的值

## 3 C++中的const

- 在c++中，一个const不必创建内存空间
  - 若const仅仅用来把一个名字用一个值代替(就像使用#define一样)，那么该存储局空间就不必创建
  - 若取一个const地址, 或者把它定义为extern,则会为该const创建内存空间

- const和#define区别总结

  - const有类型，可进行编译器类型安全检查，而#define无类型，不可进行类型检查

  - const有作用域，而#define不重视作用域

    > #define作用域从定义到文件结束或者到#undef

- 通过指针间接修改const值

  - c/c++中的全局const，直接修改失败，间接修改语法通过，但会运行失败
  - c中的局部const，不能通过变量直接修改const只读变量的值，但是可以通过指针间接修改const值
  - c++中的局部cons，直接修改const值失败，通过间接修改const值也失败

  > c++中：
  >
  > - 对于基础数据类型，如const int a = 10，编译器会把它放到符号表中，不分配内存
  >
  >   当对其取地址时，会分配内存
  >
  >   例如：`int* p = (int*)&a;`
  >
  > - 对于基础数据类型，如果用一个变量初始化const变量，是会给const变量分配内存
  >
  >   例如：`const int a = b;`
  >
  > - 对于自定数据类型，比如类对象，那么也会分配内存，可以通过指针间接修改const值

- const链接属性

  - c中const默认为外部连接，c++中const默认为内部连接
  - 如果想让c++中的const具有外部连接，必须显示声明为: `extern const int a = 10;`
  - c++中其他的标识符一般默认为外部连接

  > 对于外部连接，当两个文件中都有`const int a`的时候，编译器会报重定义的错误
  >
  > 对于内部连接，则不会报错

## 4 引用

> 引用可以作为一个已定义变量的别名
>
> 格式：`Type& ref = val;`

- 必须在声明引用变量时进行初始化
- c++增加另外一种给函数传递地址的途径，这就是按引用传递
- 引用的本质在c++内部实现是一个指针常量

### 4.1 数组的引用

> 可以建立对数组的引用，不能有NULL引用

- 直接建立引用

  ```
  int arr[10];
  int(&pArr)[10] = arr;
  ```

- 先定义出数组类型，再通过类型定义引用

  ```
  int arr[10];
  typedef int ArrRef[10];	
  ArrRef& ARef = arr;
  ```

### 4.2 指针的引用

- 利用引用可以简化指针

- 可以直接用同级指针的引用，给同级指针分配空间

### 4.3 常量的引用

> 常量引用的使用场景：修饰函数中的形参，防止误操作

- 对于`const int &ref = 10;`添加const之后，相当于写成

  ```
  int temp = 10;  
  const int &ref = temp;
  ```

### 4.4 函数中的引用

- 当引用被用作函数参数的时，在函数内对任何引用的修改，将对函数外的参数产生改变
  - 如果函数做左值，那么必须返回引用
  - 不能返回局部变量的引用

### 4.5 常量引用

> 格式：`const Type& ref = val;`

- 常量引用主要用在函数的形参，尤其是类的拷贝/复制构造函数
- 如果希望实参随着形参的改变而改变，那么使用一般的引用，如果不希望实参随着形参改变，那么使用常引用

## 5 内联函数

> 在普通函数(非成员函数)函数前面加上inline关键字使之成为内联函数（必须函数体和声明结合在一起）
>
> - 在函数声明和实现中同时加入关键字inline才称为内联
> - 任何在类内部定义的函数自动成为内联函数
> - 内联仅仅只是给编译器一个建议，编译器不一定会接受这种建议

- 内联函数相对于普通函数的优势只是省去了函数调用时候的压栈，跳转，返回的开销

> 使用预处理宏会出现两个问题：
>
> - 宏看起来像一个函数调用，但是会有隐藏一些难以发现的错误
> - 预定义宏函数没有作用域概念，不能用作类的成员函数

- 如果没有将函数声明为内联函数，那么编译器也可能将此函数做内联编译
- 编译器可能考虑不会将函数进行内联编译：
  - 存在任何形式的循环语句
  - 存在过多的条件判断语句
  - 对函数进行取址操作
  - 函数体过于庞大

## 6 函数的参数

### 6.1 函数的默认参数

- c++在声明函数原型的时可为一个或者多个参数指定默认(缺省)的参数值

- `void TestFunc02(int a,int b = 10,int c = 10){}`

  形参b设置默认参数值，那么后面位置的形参c也需要设置默认参数

- 如果函数声明和函数定义分开，函数声明设置了默认参数，函数定义不用再设置默认参数

### 6.2 函数的占位参数

- c++在声明函数时，可以设置占位参数，调用时候必须要传入占位值
- 占位参数只有参数类型声明，而没有参数名声明
- 一般情况下，在函数体内部无法使用占位参数
  - 操作符重载的后置++要用到
- 占位参数也可以有默认值

### 6.3 函数重载

> c++中允许出现同名的函数，这种现象称为函数重载

- 函数重载和默认参数一起使用，需要额外注意二义性问题的产生
- 加const和不加const的引用可以作为重载条件
- 实现函数重载的条件：
  - 同一个作用域、参数个数不同、参数类型不同、参数顺序不同

## 7 extern "C"

> 主要作用就是为了实现c++代码能够调用其他c语言代码
>
> - C++中有函数重载，会对函数名称做修饰，导致调用C语言的函数链接失败
> - 加上extern "C"后，这部分代码编译器按c语言的方式进行编译和链接，而不是按c++的方式

- 使用方式

  - 告诉编译器show函数用C语言方式做链接

    ```
    extern "C" void show();
    ```

  - 在C语言的头文件中加入代码

    ```
    #ifdef __cplusplus
    extern "C" {
    #endif
    ...
    #ifdef __cplusplus
    }
    #endif
    ```

    

