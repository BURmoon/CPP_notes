## 1 封装

> 把变量（属性）和函数（操作）合成一个整体，封装在一个类中，对变量和函数进行访问控制

### 1.1 访问权限

- class默认访问权限为private，struct默认访问权限为public

- 在类的内部(作用域范围内)，没有访问权限之分，所有成员可以相互访问
- 在类的外部(作用域范围外)，访问权限才有意义：public，private，protected
  - 在类的外部，只有public修饰的成员才能被访问
  - 在没有涉及继承与派生时，private和protected是同等级的，外部不允许访问

### 1.2 对象成员

> 在类中定义的数据成员一般都是基本的数据类型，但是类中的成员也可以是对象，叫做对象成员

- 当调用构造函数时，首先按各对象成员在类定义中的顺序（和参数列表的顺序无关）依次调用它们的构造函数，对这些对象初始化，最后再调用本身的函数体

  即，先调用对象成员的构造函数，再调用本身的构造函数

### 1.3 explicit关键字

> 禁止通过构造函数进行的隐式转换，防止利用隐式类型转换方式来构造对象

- 声明为explicit的构造函数不能在隐式转换中使用

## 2 构造函数

> 主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用

- 构造函数函数名和类名相同，没有返回值，不能有void，但可以有参数

### 2.1初始化列表

> 语法：构造函数名称 : 属性(值), 属性（值）...

- 初始化成员列表(参数列表)只能在构造函数使用
- 利用初始化列表语法，对类中属性进行初始化

### 2.2 构造函数分类：

- 按参数类型：分为无参构造函数和有参构造函数

- 按类型分类：普通构造函数和拷贝构造函数(复制构造函数)

  - 拷贝构造函数(复制构造函数)：使用另一个对象初始化本对象

  ```
  例如：Person(const Person& person){}；
  ```

  - 不能调用拷贝构造函数去初始化匿名对象

### 2.3 构造函数使用

- 括号法

```
有参--Person person01(100);		拷贝--Person person02(person01);
```

- 匿名对象

```
有参--Person(200);				有参--Person person03 = Person(300);
有参--Person person06(Person(400));	//等价于 Person person06 = Person(400);
```

- =号法(隐式转换)

```
有参--Person person04 = 100;		//Person person04 =  Person(100)
拷贝--Person person05 = person04; //Person person05 =  Person(person04)
```

### 2.4 构造函数调用规则

- 默认情况下，c++编译器至少为我们写的类增加3个函数
  - 默认构造函数(无参，函数体为空)
  - 默认析构函数(无参，函数体为空)
  - 默认拷贝构造函数，对类中非静态成员属性简单值拷贝
- 如果用户定义拷贝构造函数，c++不会再提供任何默认构造函数
- 如果用户定义了普通构造(非拷贝)，c++不在提供默认无参构造，但是会提供默认拷贝构造

> 不要用括号法调用无参构造函数
>
> `Person p3();`	//编译器认为代码是函数的声明

> 不要用拷贝构造函数初始化匿名对象
>
> `Person(p3)`		//编译器认为是Person p3对象实例化，如果已经有p3，p3就重定义

## 3 析构函数

> 主要用于对象销毁前系统自动调用，执行一些清理工作

- 析构函数函数名是在类名前面加”~”组成,没有返回值，不能有void，不能有参数，不能重载

## 4 拷贝构造函数

- 拷贝构造函数的调用时机
  - 对象以值传递的方式传给函数参数
  - 函数局部对象以值传递的方式从函数返回
  - 用一个对象初始化另一个对象

> 深拷贝与浅拷贝
>
> - 如果有属性开辟到堆区，利用编译器提供拷贝构造函数会调用浅拷贝，带来析构重复释放堆区内存的问题
> - 利用深拷贝解决浅拷贝问题：自己提供拷贝构造函数，实现深拷贝

## 5 动态分配内存

- new

  - 当用new创建一个对象时，在堆区为对象分配内存并调用构造函数完成初始化
  - 不要用void\*去接受new出来的对象，利用void\*无法调用析构函数

- delete

  - delete表达式先调用析构函数，然后释放内存

  - 如果使用一个由malloc创建的对象使用delete，这个行为是未定义的；

    因为大多数new和delete的实现机制都使用了malloc和free，所以很可能没有调用析构函数就释放了内存

  - 如果对一个void*指针执行delete操作，这将可能成为一个程序错误；

    因为它将不执行析构函数，导致可用内存减少

> malloc
>
> - 必须确定对象的长度
> - malloc返回一个void\*指针，c++不允许将void\*赋值给其他任何指针，必须强转
> - malloc可能申请内存失败，所以必须判断返回值来确保内存分配成功
> - malloc不会调用构造函数，在使用对象之前必须进行初始化

## 6 静态成员

> 类的成员可以用关键字static声明为静态成员
>
> - 不管一个类创建了多少个对象，静态成员只有一个拷贝，这个拷贝被所有属于这个类的对象共享

### 6.1 静态成员变量

- 静态成员也有访问权限，类外不能访问私有成员

- 静态变量，是在编译阶段就分配空间。即，对象还没有创建时就已经分配空间
- 静态成员变量必须在类中声明，在类外定义(类外初始化，初始化时不加static)
- 静态数据成员不属于某个对象，在为对象分配空间中不包括静态成员所占空间
- 静态数据成员可以通过类名或者对象名来引用

### 6.2 静态成员函数

- 静态成员函数也有访问权限，类外无法访问私有静态成员函数

- 静态成员函数主要为了访问静态变量，不能访问普通成员变量
- 普通成员函数可访问静态成员变量、也可以访问非经常成员变量
- 静态成员函数的意义，不在于信息共享，数据沟通，而在于管理静态数据成员，完成对静态数据成员的封装

### 6.3 const静态成员属性

- 如果一个类的成员，既要实现共享，又要实现不可改变，那就用static const修饰
- 定义静态const数据成员时，最好在类内部初始化



