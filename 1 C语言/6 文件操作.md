## 1 流

> 字节在设备、文件和程序之间的传输就是流
>
> 流是对输入输出源的一种抽象，也是对传输信息的一种抽象

- C语言中，I/O操作可以简单地看作是从程序移进或移出字节，这种搬运的过程便称为流(stream)

## 2 文件I/O

### 2.1 文件指针

- 程序为同时处于活动状态的每个文件声明一个指针变量，其类型为FILE*

- 指针指向这个FILE结构，当它处于活动状态时由流使用

### 2.2 文件缓冲区

- 应用缓冲区可大大提高计算机的运行速度

### 2.3 相关函数

- fopen()

> 文件的打开操作，即给用户指定的文件在内存分配一个FILE结构区，并将该结构的指针返回给用户程序
>
> 用户程序就可用此FILE指针来实现对指定文件的存取操作
>
> ```
> FILE * fopen(const char * filename, const char * mode);
> --filename：需要打开的文件名，根据需要加上路径
> --mode：打开文件的权限设置
> 返回值：成功则返回文件指针(失败：NULL)
> ```
>
> - 文件的权限
>
> | “r”   | 打开，只读，文件必须已经存在                                 |
> | ----- | ------------------------------------------------------------ |
> | “w”   | 只写,如果文件不存在则创建，如果文件已存在替换掉原来的文件内容文件指针指到头 |
> | “a”   | 只能在文件末尾追加数据,如果文件不存在则创建                  |
> | “w+”  | 允许读和写,如果文件不存在则创建，如果文件已存在则把文件长度截断为0字节再重新写 |
> | “a+”  | 允许读和追加数据,如果文件不存在则创建                        |
> | “rb”  | 打开一个二进制文件，只读                                     |
> | “wb”  | 打开一个二进制文件，只写                                     |
> | “ab"  | 打开一个二进制文件，追加                                     |
> | “r+”  | 允许读和写,文件必须已存在                                    |
> | “rb+” | 以读/写方式打开一个二进制文件                                |
> | “wb+” | 以读/写方式建立一个新的二进制文件                            |
> | “ab+” | 以读/写方式打开一个二进制文件进行追加                        |
>
> - “w” 权限
>
>   “w”权限对于已存在的文件，实际上是把文件长度截断(Truncate)为0字节，再重新写

- fclose

> 对打开的文件进行关闭，此时停留在文件缓冲区的未被写入的内容才能写到该文件中去
>
> 一旦关闭了文件，该文件对应的FILE结构将被释放，从而使关闭的文件得到保护
>
> ```
> int fclose(FILE * stream);
> --stream：文件指针
> 返回值：成功则返回0(失败：-1)
> ```

## 3 文件读写函数

- feof

> 检测是否读取到了文件结尾
>
> ```
> int feof(FILE * stream);
> --stream：文件指针
> 返回值：
> 		非0值：已经到文件结尾
> 		0：没有到文件结尾
> ```

### 3.1 字符读写文件

- fputc

> 将ch转换为unsigned char后写入stream指定的文件中
>
> ```
> int fputc(int ch, FILE * stream);
> --ch：需要写入文件的字符
> --stream：文件指针
> 返回值：
> 		成功：成功写入文件的字符
> 		失败：返回-1
> ```

- fgetc

> 从stream指定的文件中读取一个字符
>
> ```
> int fgetc(FILE * stream);
> --stream：文件指针
> 返回值：
> 		成功：返回读取到的字符
> 		失败：-1
> ```

### 3.2 行读写文件

- fputs()

> 将str所指定的字符串写入到stream指定的文件中， 字符串结束符 '\0'  不写入文件
>
> ```
> int fputs(const char * str, FILE * stream);
> --str：字符串
> --stream：文件指针
> 返回值：
> 		成功：0
> 		失败：-1
> ```

- fgets()

> 从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\0' 作为字符串结束
>
> ```
> char * fgets(char * str, int size, FILE * stream);
> --str：字符串
> --size：指定最大读取字符串的长度（size - 1）
> --stream：文件指针
> 返回值：
> 		成功：成功读取的字符串
> 		读到文件尾或出错：NULL
> ```

### 3.3 块读写文件

- fread()

> 以数据块的方式从文件中读取内容
>
> ```
> size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
> --ptr：存放读取出来数据的内存空间
> --size： 指定读取文件内容的块数据大小
> --nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb
> --stream：已经打开的文件指针
> 返回值：
> 		成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。
> 		失败：0
> ```

- fwirte()

> 以数据块的方式给文件写入内容
>
> ```c
> size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
> --ptr：准备写入文件数据的地址
> --size：指定写入文件内容的块数据大小
> --nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb
> --stream：已经打开的文件指针
> 返回值：
> 		成功：实际成功写入文件数据的块数，此值和nmemb相等
> 		失败：0
> ```

### 3.4 格式化读写文件

- fscanf()

> 从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据
>
> fscanf遇到空格和换行时结束
>
> ```
> int fscanf(FILE * stream, const char * format, ...);
> --stream：已经打开的文件
> --format：字符串格式，用法和scanf()一样
> 返回值：
> 		成功：实际从文件中读取的字符个数
> 		失败： -1
> ```
>
> 示例：`fscanf(fp_read, "%s", temps);`

- fprintf()

> 根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，出现字符串结束符 '\0'  为止
>
> ```
> int fprintf(FILE * stream, const char * format, ...);
> --stream：已经打开的文件
> --format：字符串格式，用法和printf()一样
> 返回值：
> 		成功：实际写入文件的字符个数
> 		失败：-1
> ```
>
> 示例：`fprintf(fp_write,"hello world:%d!",10);`

### 3.5 随机位置读写文件

- fseek()

> 移动文件流（文件光标）的读写位置
>
> ```
> int fseek(FILE *stream, long offset, int whence);
> --stream：	已经打开的文件指针
> --offset：	根据whence来移动的位移数（偏移量），可以是正数，也可以负数
> 			如果正数，则相对于whence往右移动
> 			如果是负数，则相对于whence往左移动
> 			如果向前移动的字节数超过了文件开头则出错返回
> 			如果向后移动的字节数超过了 文件末尾，再次写入时将增大文件尺寸
> --whence：	其取值如下：
> 			SEEK_SET：从文件开头移动offset个字节
> 			SEEK_CUR：从当前位置移动offset个字节
> 			SEEK_END：从文件末尾移动offset个字节
> 返回值：
> 		成功：0
> 		失败：-1
> ```

- ftell()

> 获取文件流（文件光标）的读写位置
>
> ```
> long ftell(FILE *stream);
> --stream：已经打开的文件指针
> 返回值：
> 		成功：当前文件流（文件光标）的读写位置
> 		失败:-1
> ```

- rewind()

> 把文件流（文件光标）的读写位置移动到文件开头
>
> ```
> void rewind(FILE *stream);
> --stream：已经打开的文件指针
> 返回值：
> 		无返回值
> ```
