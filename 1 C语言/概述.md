## 1 C语言特点
优点：代码量小 执行速度快 功能强大 编程自由

缺点：写代码实现周期长 可移植性较差 过于自由，经验不足易出错 对平台库依赖较多 

## 2 include头文件
由#开头的行，都代表预编译指令

### 2.1 编译过程

- 预处理
  - 宏定义展开、头文件展开、条件编译等，同时将代码中的注释删除，不会检查语法
- 编译
  - 检查语法，将预处理后文件编译生成汇编文件(.s文件)
- 汇编
  - 将汇编文件生成目标文件(.o文件)
- 链接
  - 把库链接到最终的可执行程序中去

> #include< > 与 #include ""的区别：
>
> - < >：表示系统直接按系统指定的目录检索
>
> - " "：表示系统先在 "" 指定的路径(没写路径代表当前路径)查找头文件，如果找不到，再按系统指定的目录检索

> 防止头文件重复包含
>
> - 法一：
>
>   ```
>   #ifndef __SOMEFILE_H__
>   #define __SOMEFILE_H__
>   // 声明语句
>   #endif
>   ```
>
> - 法二：
>
>   ```
>   #pragma once
>   // 声明语句
>   ```

## 3 声明和定义

*声明变量*

- 不需要建立存储空间(没有空间，就无法赋值)，如：`	extern int a;`

*定义变量*

- 需要建立存储空间，如：`int b;`

##  4 转义字符
| \a   | 警报                                |
| ---- | ----------------------------------- |
| \b   | 退格(BS) ，将当前位置移到前一列     |
| \f   | 换页(FF) ，将当前位置移到下页开头   |
| \n   | 换行(LF) ，将当前位置移到下一行开头 |
| \r   | 回车(CR) ，将当前位置移到本行开头   |
| \t   | 水平制表(HT) （跳到下一个TAB位置）  |
| \v   | 垂直制表(VT)                        |
| \0   | 数字0                               |

## 5 二进制

*bit(比特)*	

- 一个二进制代表一位（0,1），数据传输是习惯以“位”（bit）为单位

*Byte(字节)*

- 一个字节为8个二进制，称为8位，数据存储是习惯以“字节”（Byte）为单位

| 1b   | 1bit        | 1位  |
| ---- | ----------- | ---- |
| 1    | 1Byte,1字节 | 8位  |
| 1k   | 1024B       |      |

### 5.1 补码
- 对于正数，原码、反码、补码相同
- 对于负数，其补码为它的反码加1
- 补码符号位不动，其他位求反，最后整个数加1，得到原码
- 两个用补码表示的数相加时，如果最高位(符号位)有进位，则进位被舍弃

> 在计算机系统中，数值一律用补码来存储。
>                 统一了零的编码
>                 将符号位和其它位统一处理
>                 将减法运算转变为加法运算

## 6 类型限定符
*extern*

- 声明一个变量，extern声明的变量没有建立存储空间。

*const*

- 定义一个常量，常量的值不能修改

*Volatile*	

- 防止编译器优化代码

*register*	

- 定义寄存器变量，提高效率
- register是建议型的指令，而不是命令型的指令
  - 如果CPU有空闲寄存器，那么register就生效
  - 如果没有空闲寄存器，那么register无效

## 7 类型转换

*自动转换(隐式转换)*

- 遵循一定的规则,由编译系统自动完成

*强制类型转换*

- 格式：(类型说明符) (表达式)
- 把表达式的运算结果强制转换成所需的数据类型

> 类型转换的原则： 
>
> ​	占用内存字节数少(值域小)的类型，向占用内存字节数多(值域大)的类型转换，以保证精度不降低

## 8 三目运算符

格式：`c = ( a > b ? a : b );`

## 9 结构体

定义结构体类型时，编译器没有为其分配空间

只有根据其类型定义变量时，才分配空间，有空间后才能赋值

> 定义结构体变量的方式
>
> - 先声明结构体类型再定义变量名
> - 在声明类型的同时定义变量
> - 直接定义结构体类型变量(无类型名)

### 9.1 结构体成员的使用

- 在栈上分配空间
  - 如果是普通变量，通过点运算符操作结构体成员
- 在堆上分配空间
  - 如果是指针变量，通过->操作结构体成员

### 9.2 结构体字节对齐

结构体总的大小，也就是sizeof的结果，必须是 min(结构体内部最大成员，#pargama pack(n)) 的整数倍，不足要补齐

> #pargama pack(n)
>
> - 每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)
> - 可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数
> - 其中的n就是要指定的“对齐系数”

> 对齐策略，没用#pragma pack(n)指定
>
> - 结构体变量的首地址能够被其最宽基本类型成员的大小所整除
> - 结构体每个成员相对于结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节
> - 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节

### 9.3 结构体嵌套

- 结构体可以嵌套另外一个结构体的任何类型变量

- 结构体不可以嵌套本结构体普通变量
  - 本结构体的类型大小无法确定，类型本质：固定大小内存块别名;
  - 结构体可以嵌套本结构体指针变量，指针变量的空间能确定

## 10 跳转语句

*break语句*

- 在switch条件语句中时，作用是终止某个case并跳出switch结构

- 在循环语句中，作用是跳出当前内循环语句，执行后面的代码

- 在嵌套循环语句中，跳出最近的内循环语句，执行后面的代码

*continue语句*

- 在循环语句中，作用是立即终止本次循环，并执行下一次循环

*goto语句*

- 无条件跳转

## 11 内存分区

*代码区(text segment)*

- 所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的

*未初始化数据区(BSS)*

- 该区包含：全局未初始化，静态未初始化数据

- 存储于数据段的数据的生存周期为整个程序运行过程

- 未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者空（NULL）

*全局初始化数据区/静态数据区(data segmen)*

- 该区包含了在程序中明确被初始化的全局变量、已经初始化的静态变量和常量数据

- 存储于数据段的数据的生存周期为整个程序运行过程

*栈区(stack)*

- 栈是一种先进后出的内存结构，由编译器自动分配释放
- 存放函数的参数值、返回值、局部变量等

- 局部变量的生存周期为申请到释放该段栈空间

*堆区(heap)*

- 堆在内存中位于BSS区和栈区之间

- 一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收

> 数据区包括：堆，栈，全局/静态存储区
>
> - 全局/静态存储区包括：常量区，全局区、静态区
>
> - 常量区包括：字符串常量区、常变量区
>
> 代码区：存放程序编译后的二进制代码，不可寻址区

## 10 函数

*函数名*

- 函数名相当于一个指向其函数入口指针常量
- 函数名后面加圆括号，表示函数调用

*形参列表*

- 在定义函数时指定的形参，未出现函数调用时，并不占内存中的存储单元
- 在调用函数时，编译系统临时给形参分配存储单元
- 调用结束后，形参单元被释放

*函数体*

- 函数功能实现的过程

*返回值*

- 函数的返回值是通过函数中的return语句获得的
- return后面的值也可以是一个表达式
