## 1 gcc

- 常用参数
  - -v	--查看gcc版本号(version
  - -E	--生成预处理文件
  - -S	--生成汇编文件
  - -c 	--只编译, 生成.o文件
  - -I	--指定头文件所在的路径
  - -L	--指定库文件所在的路径-
  - o	--指定生成的目标文件的名字
  - -g	--包含调试信息, 使用gdb调试需要添加-g参数
  - -On n=0∼3	--编译优化,n越大优化得越多
  - -Wall	--提示更多警告信息
  - -D	--编译时定义宏

- gcc的工作流程

  - 预处理	cpp预处理器去掉注释，展开头文件，宏替换

    `gcc -E test.c -o test.i`

  - 编译	gcc，将源代码文件编译成汇编语言代码

    `gcc -S test.i -o test.s`

  - 汇编	as，将汇编语言代码编译成了二进制文件(目标代码)

    `gcc -c test.s -o test.o`

  - 链接	ld，链接代码中调用的库函数

    `gcc -o test test.o`

## 2 静态库

> 静态库可以认为是一些目标代码的集合，是在可执行程序运行前就已经加入到执行码中，成为执行程序的一部分

- 静态库命名
  - 前缀：lib
  - 库名称：自定义
  - 后缀：.a

- 静态库制作

  - 步骤1：将c源文件生成对应的.o文件

    > `gcc -c fun1.c fun2.c`
    >
    > 或
    >
    > `gcc -c fun1.c -o fun1.o`
    >
    > `gcc -c fun2.c -o fun2.o`

  - 步骤2：使用打包工具ar将准备好的.o文件打包为.a文件

    > 命令：ar rcs 静态库名 .o文件	(r更新、c创建、s建立索引)
    >
    > `ar rcs libtest1.a fun1.o fun2.o`

- 静态库使用

  `gcc -o main1 main.c -L./ -ltest1 -I./`

  - -L：指定要连接的库的所在目录
  - -l(小L)：指定链接时需要的静态库, 去掉前缀和后缀
  - -I(大i)：指定main.c文件用到的头文件所在的路径

- 静态库的优缺点

  - 优点：函数库最终被打包到应用程序中，实现是函数本地化，寻址方便、速度快

    ​			程序在运行时与函数库再无瓜葛，移植方便

  - 缺点：消耗系统资源较大, 每个进程使用静态库都要复制一份, 无端浪费内存

    ​			静态库会给程序的更新、部署和发布带来麻烦

## 2 共享库/动态库

> 共享库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入
>
> 不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的拷贝，规避了空间浪费问题

- 共享库命名

  - 前缀：lib
  - 库名称：自定义
  - 后缀：.so

- 共享库制作

  - 步骤1：生成目标文件.o, 此时要加编译选项-fPIC(fpic)

    `gcc -fpic -c fun1.c fun2.c`

  - 步骤2：生成共享库, 此时要加链接器选项-shared(指定生成动态链接库)

    `gcc -shared fun1.o fun2.o -o libtest2.so`

  > fpic创建与地址无关的编译程序(pic, position independent code), 目的就是为了能够在多个应用程序间共享

- 共享库的使用(跟静态库方式一样)

- 动态库的优缺点

  - 优点：节省内存

    ​			部署升级更新方便,，只需替换动态库即可，然后再重启服务

  - 缺点：加载速度比静态库慢

    ​			移植性差，需要把所有用到的动态库都移植

