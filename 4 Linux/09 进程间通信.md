## 1 进程间通信方式

- 管道
  - 使用最简单
  - 最基本的IPC机制，也称匿名管道
- 信号
  - 开销最小
- 共享映射区
  - 无血缘关系
  - 存储映射I/O，使一个磁盘文件与存储空间中的一个缓冲区相映射
- 本地套接字
  - 最稳定

## 2 管道pipe

> 管道的本质是一块内核缓冲区，默认缓冲区大小为4K
>
> ```
> int pipe(int fd[2]);
> --fd[0]存放管道的读端，fd[1]存放管道的写端 
> 函数返回值
> 	成功返回0
> 	失败返回-1，并设置errno值
> ```

- 调用pipe函数即可创建一个管道，应用于有血缘关系的进程之间，完成数据传递
  - 由两个文件描述符引用，一个表示读端，一个表示写端
    - 数据从管道的写端流入管道，从读端流出
    - 管道的读端和写端默认都是阻塞的
  - 当两个进程都终结的时候，管道也自动消失
  - 数据只能在一个方向上流动，若要实现双向流动，必须使用两个管道

- 父子进程使用管道通信
  - 第1步：父进程创建管道，得到两个文件描述符 fd[0] 和 fd[1]
  - 第2步：父进程 fork 出子进程，子进程也有两个文件描述符指向同一管道
  - 第3步：父进程关闭 fd[0]，子进程关闭 fd[1]
    - 父进程可以向管道中写入数据，子进程将管道中的数据读出

- 管道的读写行为

  - 读操作

    - 有数据	read正常读，返回读出的字节数

    - 无数据	

      写端全部关闭	read解除阻塞，返回0

      没有全部关闭	read阻塞

  - 写操作

    - 读端全部关闭	管道破裂，进程终止, 内核给当前进程发SIGPIPE信号

    - 读端没全部关闭	

      缓冲区写满	write阻塞

      缓冲区没满	继续write

- 设置管道为非阻塞

  ```
  int flags = fcntl(fd[0], F_GETFL, 0); 
  flag |= O_NONBLOCK;
  fcntl(fd[0], F_SETFL, flags);
  ```

  - 读端设置为非阻塞
    - 写端没有关闭，管道中没有数据可读，则read返回-1
    - 写端没有关闭，管道中有数据可读，则read返回实际读到的字节数
    - 写端已经关闭，管道中有数据可读，则read返回实际读到的字节数
    - 写端已经关闭，管道中没有数据可读，则read返回0

## 3 命名管道FIFO

> FIFO是Linux基础文件类型中的一种，在磁盘上没有数据块，文件大小为0

- 命名管道使不相关的进程也能交换数据

  - FIFO文件仅仅用来标识内核中一条通道(读写内核缓冲区)
  - 对FIFO的读总是从开始处返回数据，写则把数据添加到末尾
  - FIFO文件不支持诸如 lseek() 等文件定位操作

- 创建命名管道

  - 使用命令

    `mkfifo 管道名`

  - 使用函数

    `int mkfifo(const char *pathname, mode_t mode);`

- 使用FIFO完成两个进程通信

  - 进程A
    - 创建一个fifo文件：myfifo
    - 调用open函数打开myfifo文件
    - 调用write函数写入一个字符串，将数据写入到了内核缓冲区
    - 调用close函数关闭myfifo文件
  - 进程B
    - 调用open函数打开myfifo文件
    - 调用read函数读取文件内容，从内核中读取数据
    - 调用close函数关闭myfifo文件

## 4 内存映射区

> 存储映射I/O (Memory-mapped I/O) 使一个磁盘文件与存储空间中的一个缓冲区相映射
>
> - 从缓冲区中取数据，就相当于读文件中的相应字节
> - 将数据写入缓冲区，则会将数据写入文件
> - 这样，就可在不使用read和write函数的情况下，使用地址(指针)完成I/O操作

- 建立存储映射区

  ```
  void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
  --addr：指定映射的起始地址, 通常设为NULL, 由系统指定
  --length：映射到内存的文件长度 > 0
  --prot：映射区的保护方式, PROT_READ、PROT_WRITE、PROT_READ | PROT_WRITE
  --flags：映射区的特性，MAP_SHARED、MAP_PRIVATE
  	MAP_SHARED: 写入映射区的数据会写回文件, 且允许其他映射该文件的进程共享
  	MAP_PRIVATE: 对映射区的写入操作会产生一个映射区的复制, 对此区域所做的修改不会写回原文件
  --fd：由open返回的文件描述符, 代表要映射的文件
  --offset：以文件开始处的偏移量, 必须是4k的整数倍, 通常为0, 表示从文件头开始映射
  函数返回值
  	成功：返回创建的映射区首地址
  	失败：返回MAP_FAILED宏
  ```

  - mmap函数建立匿名映射

    `mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);`

- 释放由mmap函数建立的存储映射区

  ```
  int munmap(void *addr, size_t length);
  --addr：调用mmap函数成功返回的映射区首地址
  --length：映射区大小（mmap函数的第二个参数）
  函数返回值
  	成功：返回0
  	失败：返回-1，设置errno值
  ```

- mmap注意事项
  - 创建映射区的过程中，隐含着一次对映射文件的读操作，将文件内容读取到映射区
  - 当MAP_SHARED时，要求：映射区的权限应 <=文件打开的权限
  - 映射区的释放与文件关闭无关，只要映射建立成功，文件可以立即关闭
  - 当映射文件大小为0时，不能创建映射区
  - munmap传入的地址一定是mmap的返回地址
  - 文件偏移量必须为0或者4K的整数倍
  - mmap创建映射区出错概率非常高，一定要检查返回值

