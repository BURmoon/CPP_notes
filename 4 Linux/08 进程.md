## 1 进程

- 进程概述

  - 程序：编译好的二进制文件，占用磁盘空间, 是一个静态的概念
  - 进程：一个启动的程序，进程占用的是系统资源
  - 并发、并行
    - 并发：在一个时间段内，一个CPU上，同时运行多个程序
    - 并行：两个或两个以上的程序在同一时刻发生

- PCB进程控制块

  每个进程在内核中都有一个进程控制块(PCB)来维护进程相关的信息

  - 内部成员有
    - 进程id：系统中每个进程有唯一的id，在C语言中用pid_t类型表示
    - 进程的状态：初始态，就绪态，运行态，挂起态与终止态
    - 文件描述符表：包含很多指向file结构体的指针

- 父子进程不能共享全局变量

- 在一个进程内部执行系统命令或者是应用程序

  先fork(), 然后在子进程里面执行execl拉起可执行程序或者命令

- SIGCHLD信号

  - 产生SIGCHLD信号的条件
    - 子进程结束的时候
    - 子进程收到SIGSTOP信号
    - 当子进程停止时，收到SIGCONT信号
  - 子进程退出后，内核会给它的父进程发送SIGCHLD信号，父进程收到这个信号后可以对子进程进行回收

## 2 创建进程

- fork函数

  > 创建子进程
  >
  > ```
  > pid_t fork(void);
  > 函数返回值
  > 	调用成功：父进程返回子进程的PID，子进程返回0
  > 	调用失败：返回-1，设置errno值
  > ```
  - fork函数的返回值不是在一个进程中返回2个值，而是在父子进程各自返回一个值
  - 父子进程的执行顺序不一定，哪个进程先抢到CPU，哪个进程就先执行

- getpid/getppid函数

  > 得到当前进程的PID
  >
  > ```
  > pid_t getpid(void);
  > ```
  >
  > 得到当前进程的父进程的PID
  >
  > ```
  > pid_t getppid(void);
  > ```

## 3 进程回收

> 当一个进程退出之后，进程能够回收自己的用户区的资源，但是不能回收内核空间的PCB资源
>
> 必须由它的父进程调用wait或者waitpid函数完成对子进程的回收，避免造成系统资源的浪费

- 孤儿进程

  > 子进程的父进程已经死掉，而子进程还存活着，则该子进程就成了孤儿进程

  - 孤儿进程会被init(pid=1)进程领养
  - init进程成为了孤儿进程的养父进程，当孤儿进程退出之后，由init进程完成对孤儿进程的回收

- 僵尸进程

  > 子进程死，父进程活， 但是父进程没有回收子进程，则该子进程就成了僵尸进程

  - 由于僵尸进程是一个已经死亡的进程，所以不能使用kill命令将其杀死
  - 通过杀死其父进程的方法可以消除僵尸进程

- wait函数

  > 阻塞并等待子进程退出、回收子进程残留资源、获取子进程结束状态
  >
  > ```
  > pid_t wait(int *status);
  > --status：传出参数，子进程的退出状态
  > 函数返回值
  > 	成功：清理掉的子进程ID
  > 	失败：-1 (没有子进程)
  > ```

  - status参数

    - WIFEXITED(status) 为非0，进程正常结束

      通过 WEXITSTATUS(status) 获取进程退出状态 

    - WIFSIGNALED(status) 为非0，进程异常终止

      通过 WTERMSIG(status) 取得进程终止的信号编号

- waitpid函数

  > 同wait函数
  >
  > ```
  > pid_t waitpid(pid_t pid, int *status, in options);
  > --pid：
  > 	pid = -1	--等待任一子进程，与wait等效
  >     pid > 0		--等待其进程ID与pid相等的子进程
  > 	pid = 0		--等待进程组ID与目前进程相同的任何子进程
  > 	pid < -1	--等待其组ID等于pid的绝对值的任一子进程
  > --status: 子进程的退出状态，用法同wait函数。
  > --options：设置为WNOHANG，函数非阻塞，设置为0，函数阻塞
  > 函数返回值
  > 	>0：返回回收掉的子进程ID；
  > 	-1：无子进程
  > 	=0：参3为WNOHANG，且子进程正在运行
  > ```

## 4 exec函数族

- exec函数在一个进程里面执行其他的命令或者是用户自定义的应用程序

  - 是用一个新程序替换了当前进程的代码段、数据段、堆和栈
  - 原有的进程空间没有发生变化，并没有创建新的进程，进程PID没有发生变化

- execl函数

  > execl函数一般执行自己写的程序
  >
  > ```
  > int execl(const char *path, const char *arg, ... /* (char  *) NULL */);
  > --path: 要执行的程序的绝对路径
  > --arg:占位，通常写应用程序的名字
  > --arg后面的: 命令的参数
  > --参数写完之后加: NULL
  > 函数返回值
  > 	成功，则不返回，不会再执行exec函数后面的代码
  > 	失败，会执行execl后面的代码，可以用perror打印错误原因
  > ```

- execlp函数

  > execlp函数一般是执行系统自带的程序或者是命令
  >
  > ```
  > int execlp(const char *file, const char *arg, .../* (char  *) NULL */);
  > --file: 执行命令的名字, 根据PATH环境变量来搜索该命令
  > --arg: 占位
  > --arg后面的: 命令的参数
  > --参数写完之后加: NULL
  > 函数返回值
  > 	成功，则不返回，不会再执行exec函数后面的代码
  > 	失败，会执行后面的代码，可以用perror打印错误原因
  > ```
  >
  > 示例：`execlp("ls", "ls", "-l", NULL);`

## 5 守护进程

> Daemon(精灵)进程，Linux后台服务进程、独立于控制终端、周期性的执行某种任务、不受用户登陆和注销的影响
>
> 名字一般采用以d结尾

- 创建守护进程的模型
  - 第1步：fork子进程，父进程退出
  - 第2步：子进程调用setsid函数创建新会话
    - 该进程成为新会话的首进程，是会话的会长
    - 成为一个新进程组的组长进程，是进程组组长
    - 不受控制终端的影响
  - 第3步：改变当前工作目录chdir
  - 第4步：重设文件掩码
  - 第5步：关闭文件描述符
    - close(STDIN_FILENO);
    - close(STDOUT_FILENO);
    - close(STDERR_FILENO);
  - 第6步：执行核心工作
- 进程组
  - 一个或者多个进程的集合，组长ID==父进程ID
  - 可以使用kill -SIGKILL -进程组ID(负的)来将整个进程组内的进程全部杀死
  - 只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关
  - 进程组生存期：从进程组创建到最后一个进程离开
- 会话
  - 一个或多个进程组的集合
  - 创建会话的进程不能是进程组组长
  - 创建会话的进程成为一个进程组的组长进程，同时也成为会话的会长
  - 新创建的会话丢弃原有的控制终端

