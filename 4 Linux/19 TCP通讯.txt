## 1 TCP通信

### 1.1 TCP通信时序

- 建立连接（三次握手）

  - 1，客户端发送一个带SYN标志的TCP报文到服务器
    - SYN位表示连接请求
    - 序号是1000，序号在网络通讯中用作临时地址
    - mss表示最大报文长度，声明自己的最大段尺寸
  - 2，服务器端回应客户端，同时带ACK标志和SYN标志
    - ACK表示对刚才客户端SYN的回应
    - 确认序号是1001，表示“接收到序号1000及其以前所有的段”
    - 发送SYN给客户端，询问客户端是否准备好进行数据通讯
  - 3，客户必须再次回应服务器端一个ACK报文

  > 在TCP通讯中，如果一方收到另一方发来的段，读出其中的目的端口号，发现本机并没有任何进程使用这个端口，就会应答一个包含RST位的段给另一方

- 关闭连接（四次握手）

  - 客户端发出，FIN位表示关闭连接的请求
  - 服务器，应答客户端的关闭连接请求
  - 服务器发出，FIN位，向客户端发送关闭连接请求
  - 客户端，应答服务器的关闭连接请求

### 1.2 滑动窗口 (TCP流量控制)

- 如果发送端发送的速度较快，接收端接收到数据后处理的速度较慢

  而接收缓冲区的大小是固定的，就会丢失数据

  TCP协议通过“滑动窗口（Sliding Window）”机制解决这一问题

- win	表示告诉对方我这边缓冲区大小是多少

  mss	表示告诉对方我这边最多一次可以接收多少数据

## 2 TCP状态时序图

- 时序

  - 主动发起连接请求端

    - 【CLOSE】 -- 发送SYN -- 【SEND_SYN】-- 接收 ACK、SYN -- 【SEND_SYN 】

      -- 发送 ACK -- 【ESTABLISHED】（数据通信态）

  - 主动关闭连接请求端

    - 【ESTABLISHED】（数据通信态） -- 发送 FIN -- 【FIN_WAIT_1 】

      -- 接收ACK -- 【FIN_WAIT_2】（半关闭）-- 接收对端发送 FIN -- 【FIN_WAIT_2】（半关闭）

      -- 回发ACK -- 【TIME_WAIT】（只有主动关闭连接方，会经历该状态）

      -- 等2MSL时长 -- 【CLOSE 】

  - 被动接收连接请求端

    - 【CLOSE 】-- 【LISTEN 】-- 接收 SYN -- 【LISTEN 】-- 发送 ACK、SYN -- 【SYN_RCVD 】

      -- 接收ACK -- 【ESTABLISHED】（数据通信态）

  - 被动关闭连接请求端

    - 【ESTABLISHED】（数据通信态） -- 接收 FIN -- 【ESTABLISHED】（数据通信态）

      -- 发送ACK -- 【CLOSE_WAIT 】(说明对端【主动关闭连接端】处于半关闭状态) 

      -- 发送FIN -- 【LAST_ACK 】-- 接收ACK -- 【CLOSE】

- 2MSL时长 

  - 保证最后一个 ACK 能成功被对端接收
  - 等待期间，对端没收到ACK，对端会再次发送FIN请求

- 端口复用

  ```
  int opt = 1;		// 设置端口复用
  setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, (void *)&opt, sizeof(opt));
  ```

- 半关闭

  - 通信双方中，只有一端关闭通信【FIN_WAIT_2】

- close（cfd）

  - 使用close中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接

    只有当描述符的引用计数为0时才关闭连接

  - shutdown不考虑描述符的引用计数，直接关闭描述符

    ```
    int shutdown(int sockfd, int how);
    --how: 	
    	SHUT_RD	关读端
    	SHUT_WR	关写端
    	SHUT_RDWR 关读写
    ```

    - 如果有多个进程共享一个套接字，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用了close，套接字将被释放
    - 在多进程中如果一个进程调用了shutdown后，其它的进程将无法进行通信

